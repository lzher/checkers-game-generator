<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è·³æ£‹æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 20px;
            margin-top: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-container {
            position: relative;
            margin-bottom: 20px;
        }
        
        canvas {
            background-color: #f0f0f0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: block;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #undoBtn {
            background-color: #3498db;
            color: white;
        }
        
        #undoBtn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        
        #restartBtn {
            background-color: #e74c3c;
            color: white;
        }
        
        #restartBtn:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            background-color: #ecf0f1;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
        }
        
        .instructions {
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            border-radius: 8px;
            margin-top: 25px;
            max-width: 800px;
        }
        
        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
            color: #555;
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .victory-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(46, 204, 113, 0.95);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        .legend-text {
            font-size: 0.9rem;
            color: #555;
        }
        
        .victory-area-label {
            margin-top: 10px;
            padding: 8px 15px;
            background: linear-gradient(90deg, rgba(144, 238, 144, 0.3), rgba(60, 179, 113, 0.3));
            border-radius: 20px;
            font-size: 0.9rem;
            color: #2e8b57;
            font-weight: 600;
            border: 2px dashed #3cb371;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            canvas {
                width: 95vw;
                height: auto;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>è·³æ£‹æ¸¸æˆ</h1>
        <div class="subtitle">åƒæ‰å½©è‰²æ£‹å­ï¼Œåˆ°è¾¾é¡¶éƒ¨è·èƒœ</div>
    </header>
    
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="gameCanvas" width="900" height="900"></canvas>
                <div class="victory-message" id="victoryMessage">ğŸ‰ èƒœåˆ©ï¼æ£‹å­å·²åˆ°è¾¾é¡¶éƒ¨ï¼</div>
            </div>
            
            <div class="controls">
                <div class="level-controls" style="width: 100%; display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
                    <select id="difficultySelect" style="padding: 12px; border-radius: 8px; border: 1px solid #ccc; font-size: 1rem;">
                        <option value="low">ä½éš¾åº¦</option>
                        <option value="medium" selected>ä¸­éš¾åº¦</option>
                        <option value="high">é«˜éš¾åº¦</option>
                    </select>
                    <button id="generateBtn" style="background-color: #9b59b6; color: white;">ç”Ÿæˆå…³å¡</button>
                    <button id="hintBtn" style="background-color: #34495e; color: white;">æ˜¾ç¤ºç­”æ¡ˆ</button>
                    <button id="copyBtn" style="background-color: #2ecc71; color: white;">å¤åˆ¶å…³å¡ä»£ç </button>
                    <button id="loadBtn" style="background-color: #f1c40f; color: black;">åŠ è½½å…³å¡ä»£ç </button>
                </div>
                <button id="undoBtn">æ’¤é”€ (Ctrl+Z)</button>
                <button id="restartBtn">é‡æ–°å¼€å§‹</button>
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">ç§»åŠ¨æ­¥æ•°</div>
                    <div class="stat-value" id="moveCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">å‰©ä½™æ£‹å­</div>
                    <div class="stat-value" id="remainingPieces">28</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // -----------------------------------------------------
        // æ¸¸æˆå¸¸é‡
        // -----------------------------------------------------
        const ROWS_LAYOUT = [1, 2, 3, 4, 13, 12, 11, 10, 9, 10, 11, 12, 13, 4, 3, 2, 1];
        const BOARD_ROWS = ROWS_LAYOUT.length;
        const BOARD_COLS = 17;
        const INVALID = -1;
        const EMPTY = 0;
        const OBSTACLE = 1;
        const PLAYER = 2;
        
        // å…­æ–¹å‘å‘é‡ï¼ˆè½´å‘åæ ‡ï¼‰
        const AXIAL_DIRS = [
            [1, 0], [1, -1], [0, -1], 
            [-1, 0], [-1, 1], [0, 1]
        ];
        
        // é¢œè‰²å®šä¹‰
        const COLORS = {
            BG: '#f0f0f0',
            EMPTY: '#e8e8e8',
            PLAYER: '#00C853',
            SELECTED: '#FFB350',
            HIGHLIGHT: '#78FF78',
            WIN_AREA: 'rgba(60, 179, 113, 0.3)',
            WIN_AREA_BG: 'rgba(144, 238, 144, 0.1)',
            WIN_AREA_BORDER: 'rgba(60, 179, 113, 0.6)',
            PURPLE: '#A020F0',
            PINK: '#FF69B4',
            YELLOW: '#FFD700',
            ORANGE: '#FF8C00',
            RED: '#DC143C',
            BLUE: '#3282FF'
        };
        
        // -----------------------------------------------------
        // æ¸¸æˆç±»
        // -----------------------------------------------------
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.board = null;
                this.boardColors = null;
                this.playerPos = null;
                this.indexToAxial = new Map();
                this.axialToIndex = new Map();
                this.selected = null;
                this.hoveredTarget = null; // æ–°å¢ï¼šé¼ æ ‡æ‚¬åœçš„ç›®æ ‡
                this.moveCount = 0;
                this.history = [];
                this.gameWon = false;
                this.remainingPieces = 28;
                this.currentLevel = null;
                
                this.initGame(true);
                this.setupEventListeners();
                this.draw();
            }
            
            initGame(isFirstInit = false) {
                // æ¸…ç©ºå†å²è®°å½•ï¼ˆé™¤éæ˜¯ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ï¼‰
                if (!isFirstInit) {
                    this.history = [];
                }
                
                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                this.setupBoard();
                this.createAxialMapping();
                this.moveCount = 0;
                this.remainingPieces = 28;
                this.remainingPieces = 28;
                this.gameWon = false;
                this.selected = null;
                this.hintPath = null;
                
                // ä¿å­˜åˆå§‹çŠ¶æ€
                this.saveState();
                
                // æ›´æ–°UIæ˜¾ç¤º
                this.updateUI();
            }
            
            createEmptyBoard() {
                const board = Array(BOARD_ROWS).fill().map(() => Array(BOARD_COLS).fill(INVALID));
                for (let r = 0; r < BOARD_ROWS; r++) {
                    const count = ROWS_LAYOUT[r];
                    const offset = Math.floor((BOARD_COLS - count) / 2);
                    for (let i = 0; i < count; i++) {
                        const c = offset + i;
                        board[r][c] = EMPTY;
                    }
                }
                return board;
            }
            
            createEmptyColorLayer() {
                return Array(BOARD_ROWS).fill().map(() => Array(BOARD_COLS).fill(null));
            }
            
            logicalToIndex(rowNo, posNo) {
                const r = rowNo - 1;
                if (r >= 0 && r < BOARD_ROWS) {
                    const count = ROWS_LAYOUT[r];
                    const offset = Math.floor((BOARD_COLS - count) / 2);
                    const c = offset + (posNo - 1);
                    if (c >= 0 && c < BOARD_COLS) {
                        return [r, c];
                    }
                }
                return null;
            }
            
            setupBoard() {
                if (this.currentLevel) {
                    this.loadLevelData(this.currentLevel);
                    return;
                }

                // è®¾ç½®éšœç¢ç‰©
                const obstacles = [
                    [5, 3, COLORS.PURPLE], [5, 11, COLORS.PURPLE],
                    [6, 5, COLORS.PURPLE], [6, 7, COLORS.PURPLE], [6, 10, COLORS.PURPLE],
                    [7, 1, COLORS.BLUE], [7, 4, COLORS.BLUE], [7, 7, COLORS.BLUE], [7, 11, COLORS.BLUE],
                    [8, 5, COLORS.BLUE], [8, 7, COLORS.BLUE], [8, 8, COLORS.BLUE], [8, 9, COLORS.BLUE],
                    [9, 5, COLORS.PINK], [9, 8, COLORS.PINK],
                    [10, 2, COLORS.YELLOW], [10, 5, COLORS.YELLOW], [10, 6, COLORS.YELLOW], [10, 8, COLORS.YELLOW],
                    [11, 1, COLORS.ORANGE], [11, 5, COLORS.ORANGE], [11, 9, COLORS.ORANGE], [11, 10, COLORS.ORANGE],
                    [13, 3, COLORS.RED], [13, 5, COLORS.RED],
                    [15, 2, COLORS.RED], [15, 3, COLORS.RED]
                ];
                
                obstacles.forEach(([row, pos, color]) => {
                    const posIdx = this.logicalToIndex(row, pos);
                    if (posIdx) {
                        const [r, c] = posIdx;
                        this.board[r][c] = OBSTACLE;
                        this.boardColors[r][c] = color;
                    }
                });
                
                // è®¾ç½®ç©å®¶
                const playerPos = this.logicalToIndex(17, 1);
                if (playerPos) {
                    const [r, c] = playerPos;
                    this.board[r][c] = PLAYER;
                    this.playerPos = [r, c];
                }
            }

            loadLevelData(levelData) {
                // æ¸…ç©ºæ£‹ç›˜
                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                
                // è®¾ç½®éšœç¢ç‰©
                levelData.obstacles.forEach(([r, c, color]) => {
                    this.board[r][c] = OBSTACLE;
                    this.boardColors[r][c] = color;
                });
                
                // è®¾ç½®ç©å®¶
                if (levelData.player) {
                    const [pr, pc] = levelData.player;
                    this.board[pr][pc] = PLAYER;
                    this.playerPos = [pr, pc];
                }
                
                this.createAxialMapping();
            }

            calculateEffectiveSteps(path) {
                if (!path || path.length < 2) return 0;
                
                // å¤‡ä»½çŠ¶æ€
                const savedBoard = this.board.map(row => [...row]);
                const savedColors = this.boardColors.map(row => [...row]);
                const savedPlayer = [...this.playerPos];
                const savedRem = this.remainingPieces;
                const savedMove = this.moveCount;
                
                let forcedSteps = 0;
                
                try {
                    // æ¨¡æ‹Ÿè·¯å¾„æ¯ä¸€æ­¥
                    for (let i = 0; i < path.length - 1; i++) {
                        const currentPos = path[i];
                        const nextPos = path[i+1];
                        
                        // ç¡®ä¿ç©å®¶åœ¨å½“å‰ä½ç½®
                        this.board[currentPos[0]][currentPos[1]] = PLAYER;
                        this.playerPos = [currentPos[0], currentPos[1]];
                        this.createAxialMapping();
                        
                        // æ£€æŸ¥å½“å‰åˆ†æ”¯æ•°
                        const jumps = this.findAllJumpsFrom(currentPos[0], currentPos[1]);
                        
                        if (jumps.length > 1) {
                            // å‘ç°åˆ†æ”¯ç‚¹ï¼Œåç»­æ­¥éª¤å‡ä¸ºæœ‰æ•ˆæ­¥éª¤
                            break;
                        }
                        
                        // åªæœ‰ä¸€ä¸ªé€‰æ‹©ï¼ˆæˆ–è€…æ²¡æœ‰é€‰æ‹©ï¼Œä½†è·¯å¾„å­˜åœ¨è¯´æ˜æœ‰ä¸€ä¸ªï¼‰ï¼Œè¿™æ˜¯å¼ºåˆ¶æ­¥éª¤
                        forcedSteps++;
                        
                        // æ‰§è¡Œè·³è·ƒæ›´æ–°ç›˜é¢
                        const jumpInfo = this.analyzeJump(currentPos[0], currentPos[1], nextPos[0], nextPos[1]);
                        if (jumpInfo) {
                            const [mr, mc] = jumpInfo.mid;
                            this.board[currentPos[0]][currentPos[1]] = EMPTY;
                            this.board[mr][mc] = EMPTY;
                            this.boardColors[mr][mc] = null;
                            this.board[nextPos[0]][nextPos[1]] = PLAYER;
                        }
                    }
                } catch (e) {
                    console.error("Error calculating effective steps", e);
                } finally {
                    // æ¢å¤çŠ¶æ€
                    this.board = savedBoard;
                    this.boardColors = savedColors;
                    this.playerPos = savedPlayer;
                    this.remainingPieces = savedRem;
                    this.moveCount = savedMove;
                    this.createAxialMapping();
                }
                
                const totalSteps = path.length - 1;
                // æœ‰æ•ˆæ­¥æ•° = æ€»æ­¥æ•° - åˆå§‹å¼ºåˆ¶æ­¥æ•°
                return Math.max(0, totalSteps - forcedSteps);
            }

            generateLevel(difficulty) {
                // éš¾åº¦è®¾ç½®
                let minSteps = 8;
                let targetBranching = 1.2; // ä½éš¾åº¦åˆ†æ”¯å°‘
                
                if (difficulty === 'medium') { 
                    minSteps = 15; 
                    targetBranching = 1.5; // ä¸­éš¾åº¦åˆ†æ”¯é€‚ä¸­
                }
                if (difficulty === 'high') { 
                    minSteps = 20; 
                    targetBranching = 2.2; // é«˜éš¾åº¦åˆ†æ”¯å¤š
                }
                
                // 1. æ¸…ç©ºæ£‹ç›˜
                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                this.createAxialMapping(); 

                // 2. éšæœºé€‰æ‹©èµ·ç‚¹ï¼ˆé¡¶éƒ¨ï¼‰å’Œ ç»ˆç‚¹ï¼ˆåº•éƒ¨ï¼‰
                const startTime = Date.now();
                const TIME_LIMIT = 10000; // 10ç§’è¶…æ—¶
                
                let success = false;
                let bestLevel = null;
                let maxEffectiveSteps = -1; // ä½¿ç”¨æœ‰æ•ˆæ­¥æ•°ä½œä¸ºè¯„ä¼°æ ‡å‡†
                
                // ç¡®å®šèµ·ç‚¹
                let startCandidates = [];
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            startCandidates.push([r, c]);
                        }
                    }
                }
                
                // ç›®æ ‡ç»ˆç‚¹åŒºåŸŸ
                let endCandidates = [];
                for (let r = 13; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            endCandidates.push([r, c]);
                        }
                    }
                }

                // å°è¯•å¤šæ¬¡ç”Ÿæˆ
                for(let i=0; i<50; i++) {
                    if (Date.now() - startTime > TIME_LIMIT) {
                        console.warn("Generation timed out!");
                        break;
                    }

                    // é‡ç½®æ£‹ç›˜
                    this.board = this.createEmptyBoard();
                    this.boardColors = this.createEmptyColorLayer();
                    
                    const [startR, startC] = startCandidates[Math.floor(Math.random() * startCandidates.length)];
                    const [endR, endC] = endCandidates[Math.floor(Math.random() * endCandidates.length)];
                    
                    // è®¾ç½®ç”Ÿæˆå™¨èµ·ç‚¹ (Game End)
                    this.board[startR][startC] = PLAYER;
                    this.playerPos = [startR, startC];
                    
                    const targetPos = [endR, endC];

                    // 3. éª¨æ¶ + å¤æ‚åŒ–
                    const skeletonPath = this.generateSkeleton(this.playerPos, targetPos, difficulty);
                    
                    if (skeletonPath) {
                        const complexPath = this.complexifyPath(skeletonPath, minSteps, startTime);
                        
                        if (complexPath.length - 1 >= minSteps) {
                            // é‡å»ºæ£‹ç›˜
                            this.board = this.createEmptyBoard();
                            this.boardColors = this.createEmptyColorLayer();
                            
                            const startNode = complexPath[complexPath.length - 1];
                            this.board[startNode[0]][startNode[1]] = PLAYER;
                            this.playerPos = [...startNode];
                            
                            for (let k = 0; k < complexPath.length - 1; k++) {
                                const p1 = complexPath[k];
                                const p2 = complexPath[k+1];
                                const jumpInfo = this.analyzeJump(p1[0], p1[1], p2[0], p2[1]);
                                if (jumpInfo) {
                                    const [mr, mc] = jumpInfo.mid;
                                    this.board[mr][mc] = OBSTACLE;
                                    this.assignRandomColor(mr, mc);
                                }
                            }
                            
                            this.createAxialMapping();
                            
                            // éªŒè¯åŸºç¡€è·¯å¾„
                            let actualPath = this.solveGameBFS(this.board, this.playerPos);
                            let actualSteps = actualPath ? actualPath.length - 1 : 0;
                            
                            if (actualPath && actualSteps >= minSteps) {
                                // 4. å¢åŠ å¹²æ‰°é¡¹ (ç°åœ¨åœ¨éªŒè¯å‰æ·»åŠ ï¼Œå› ä¸ºå¹²æ‰°é¡¹å½±å“æœ‰æ•ˆæ­¥æ•°)
                                const reservedSet = this.getReservedCellsFromPath(actualPath);
                                this.addDecoysSmartly(targetBranching, reservedSet, minSteps, actualPath);
                                
                                // 4.1 å¼ºåŠ›æå‡åˆ†æ”¯ç³»æ•°
                                this.boostBranchingFactor(targetBranching, reservedSet, minSteps);
                                
                                // é‡æ–°æ±‚è§£æœ€ç»ˆè·¯å¾„ï¼ˆå› ä¸ºå¯èƒ½äº§ç”Ÿäº†æ·å¾„ï¼Œæˆ–è€…éœ€è¦ç¡®è®¤è·¯å¾„ä»æœ‰æ•ˆï¼‰
                                actualPath = this.solveGameBFS(this.board, this.playerPos);
                                if (!actualPath) continue;
                                
                                // 5. è®¡ç®—æœ‰æ•ˆæ­¥æ•° (æ’é™¤åˆå§‹å¼ºåˆ¶ç§»åŠ¨)
                                const effectiveSteps = this.calculateEffectiveSteps(actualPath);
                                
                                if (effectiveSteps >= minSteps) {
                                    success = true;
                                    this.currentLevel = this.saveCurrentLevelData();
                                    break;
                                }
                                
                                // è®°å½•æœ€ä½³ç»“æœ
                                if (effectiveSteps > maxEffectiveSteps) {
                                    maxEffectiveSteps = effectiveSteps;
                                    bestLevel = this.saveCurrentLevelData();
                                    bestLevel.board = this.board.map(row => [...row]); // ä¿å­˜å®Œæ•´boardç”¨äºæ¢å¤
                                    bestLevel.boardColors = this.boardColors.map(row => [...row]);
                                    bestLevel.playerPos = [...this.playerPos];
                                }
                            }
                        }
                    }
                }
                
                if (!success) {
                    if (bestLevel && maxEffectiveSteps >= Math.max(3, minSteps * 0.4)) { // ç¨å¾®é™ä½é—¨æ§›
                        this.board = bestLevel.board;
                        this.boardColors = bestLevel.boardColors;
                        this.playerPos = bestLevel.playerPos;
                        this.createAxialMapping();
                        this.currentLevel = bestLevel;
                        console.log(`æœªè¾¾åˆ°ç›®æ ‡æ­¥æ•° ${minSteps}ï¼Œé™çº§ä½¿ç”¨æœ‰æ•ˆæ­¥æ•° ${maxEffectiveSteps} çš„å…³å¡`);
                    } else {
                        alert(`ç”Ÿæˆå…³å¡å¤±è´¥ï¼ˆæ— æ³•æ»¡è¶³æ­¥æ•°è¦æ±‚ï¼‰ï¼Œè¯·é‡è¯•`);
                        return;
                    }
                }
                
                // é‡ç½®æ¸¸æˆ
                this.history = [];
                this.moveCount = 0;
                this.remainingPieces = 0;
                // é‡æ–°è®¡ç®—å‰©ä½™æ£‹å­
                for(let r=0; r<BOARD_ROWS; r++) {
                    for(let c=0; c<BOARD_COLS; c++) {
                        if(this.board[r][c] === OBSTACLE) this.remainingPieces++;
                    }
                }
                
                this.gameWon = false;
                this.selected = null;
                this.hintPath = null;
                this.saveState();
                this.updateUI();
                this.draw();
                
                // æ˜¾ç¤ºæç¤º
                const victoryMsg = document.getElementById('victoryMessage');
                victoryMsg.style.display = 'block';
                const finalSol = this.solveGameBFS(this.board, this.playerPos);
                const avgBranching = this.calculateAvgBranchingFactor(finalSol);
                const effSteps = this.calculateEffectiveSteps(finalSol);
                
                victoryMsg.innerHTML = `ç”ŸæˆæˆåŠŸï¼<br>æ€»æ­¥æ•°: ${finalSol ? finalSol.length-1 : '?'} <br>æœ‰æ•ˆæ­¥æ•°: ${effSteps}<br>å¹³å‡åˆ†æ”¯: ${avgBranching.toFixed(1)}`;
                setTimeout(() => {
                    victoryMsg.style.display = 'none';
                }, 3000);
            }
            
            saveCurrentLevelData() {
                const data = {
                    obstacles: [],
                    player: this.playerPos
                };
                for(let r=0; r<BOARD_ROWS; r++) {
                    for(let c=0; c<BOARD_COLS; c++) {
                        if(this.board[r][c] === OBSTACLE) {
                            data.obstacles.push([r, c, this.boardColors[r][c]]);
                        }
                    }
                }
                return data;
            }

            // ä»è·¯å¾„ä¸­æå–æ‰€æœ‰ä¿ç•™æ ¼å­ï¼ˆèµ·ç‚¹ã€ç»ˆç‚¹ã€ä¸­é—´è¢«åƒæ‰çš„å­ã€è·¯å¾„ç»è¿‡çš„ç©ºæ ¼ï¼‰
            getReservedCellsFromPath(path) {
                const reserved = new Set();
                if (!path) return reserved;
                
                // æ·»åŠ èµ·å§‹ç‚¹
                reserved.add(`${path[0][0]},${path[0][1]}`);
                
                for (let i = 0; i < path.length - 1; i++) {
                    const [r1, c1] = path[i];
                    const [r2, c2] = path[i+1];
                    
                    // ç›®æ ‡ç‚¹
                    reserved.add(`${r2},${c2}`);
                    
                    // è®¡ç®—ä¸­é—´ç‚¹å’Œè·¯å¾„ç‚¹
                    const jumpInfo = this.analyzeJump(r1, c1, r2, c2);
                    if (jumpInfo) {
                        const { mid, pathCells } = jumpInfo;
                        reserved.add(`${mid[0]},${mid[1]}`);
                        pathCells.forEach(([pr, pc]) => reserved.add(`${pr},${pc}`));
                    }
                }
                return reserved;
            }
            
            analyzeJump(r1, c1, r2, c2) {
                const startKey = `${r1},${c1}`;
                const targetKey = `${r2},${c2}`;
                if (!this.indexToAxial.has(startKey) || !this.indexToAxial.has(targetKey)) return null;
                
                const [q1, aq1] = this.indexToAxial.get(startKey);
                const [q2, aq2] = this.indexToAxial.get(targetKey);
                
                const dq = q2 - q1;
                const dr = aq2 - aq1;
                
                // å¯»æ‰¾æœ€å¤§å…¬çº¦æ•°æˆ–ç›´æ¥åˆ¤æ–­å€æ•°
                // ç®€å•å¤„ç†ï¼šéå†æ–¹å‘
                for(const [dirQ, dirR] of AXIAL_DIRS) {
                     // æ£€æŸ¥æ˜¯å¦æ˜¯è¯¥æ–¹å‘
                     // dq = k * dirQ, dr = k * dirR
                     let k = 0;
                     if (dirQ !== 0) k = dq / dirQ;
                     else if (dirR !== 0) k = dr / dirR;
                     
                     if (k > 0 && Math.round(k * dirQ) === dq && Math.round(k * dirR) === dr) {
                         // æ‰¾åˆ°äº†æ–¹å‘å’Œå€æ•° k (factor)
                         const midK = k / 2;
                         const midQ = q1 + midK * dirQ;
                         const midR = aq1 + midK * dirR;
                         
                         const pathCells = [];
                         for(let i=1; i<k; i++) {
                             if(i === midK) continue;
                             const pq = q1 + i * dirQ;
                             const pr = aq1 + i * dirR;
                             if(this.axialToIndex.has(`${pq},${pr}`)) {
                                 pathCells.push(this.axialToIndex.get(`${pq},${pr}`));
                             }
                         }
                         
                         if(this.axialToIndex.has(`${midQ},${midR}`)) {
                             return {
                                 mid: this.axialToIndex.get(`${midQ},${midR}`),
                                 pathCells: pathCells
                             };
                         }
                     }
                }
                return null;
            }
            
            addDecoysSmartly(targetBranching, reservedSet, minSteps, initialPath) {
                // ç­–ç•¥å‡çº§ï¼šä¼˜å…ˆåˆ©ç”¨ç°æœ‰èµ„æºåˆ¶é€ åˆ†æ”¯ï¼Œä¸“æ³¨äºæ‰“ç ´â€œå•è¡Œé“â€
                // å…³é”®ç‚¹ï¼šä¸¥é˜²æ·å¾„ (Shortcuts)
                
                let currentBestPath = this.solveGameBFS(this.board, this.playerPos);
                if (!currentBestPath) return; // Should not happen
                let currentBestSteps = currentBestPath.length - 1;

                // 1. è¯†åˆ«â€œå¼ºåˆ¶ç§»åŠ¨â€ç‚¹ (Choke Points) å¹¶å°è¯•åˆ¶é€ æ­»èƒ¡åŒ
                for (let pass = 0; pass < 3; pass++) {
                    const currentPath = this.solveGameBFS(this.board, this.playerPos);
                    if (!currentPath) break;
                    
                    // æ¨¡æ‹Ÿè·¯å¾„ï¼Œæ‰¾åˆ°åˆ†æ”¯æ•°ä¸º1çš„èŠ‚ç‚¹
                    this.enhancePathBranching(currentPath, reservedSet, currentBestSteps);
                    
                    // æ›´æ–°å½“å‰æœ€ä½³æ­¥æ•° (enhancePathBranching å†…éƒ¨å¯èƒ½ä¼šå¼•å…¥è½»å¾®çš„æ­¥æ•°å˜åŒ–ï¼Œæˆ‘ä»¬æ¥å—æ›´é•¿çš„ï¼Œæ‹’ç»æ›´çŸ­çš„)
                    const newPath = this.solveGameBFS(this.board, this.playerPos);
                    if (newPath) {
                        currentBestSteps = newPath.length - 1;
                    }
                }
                
                // 2. è¡¥å……å¸¸è§„å™ªéŸ³ (å¦‚æœè¿˜éœ€è¦)
                const currentEffSteps = this.calculateEffectiveSteps(this.solveGameBFS(this.board, this.playerPos));
                if (currentEffSteps < minSteps) {
                    this.addRandomDecoys(targetBranching, reservedSet, currentBestSteps, initialPath);
                }
            }

            boostBranchingFactor(targetBranching, reservedSet, minSteps) {
                let currentBranching = this.calculateAvgBranchingFactor();
                let attempts = 0;
                const MAX_ATTEMPTS = 50; // å¢åŠ å°è¯•æ¬¡æ•°
                
                // å¾ªç¯å°è¯•ç›´åˆ°è¾¾åˆ°ç›®æ ‡åˆ†æ”¯ç³»æ•°
                while (currentBranching < targetBranching && attempts < MAX_ATTEMPTS) {
                    attempts++;
                    
                    const path = this.solveGameBFS(this.board, this.playerPos);
                    if (!path) break;
                    
                    const candidates = [];
                    
                    // éå†è·¯å¾„ä¸Šçš„ç‚¹ï¼Œå¯»æ‰¾å¯ä»¥åˆ¶é€ åˆ†æ”¯çš„ä½ç½®
                    // åªéœ€è¦é‡‡æ ·ä¸€éƒ¨åˆ†ç‚¹ï¼Œé¿å…è®¡ç®—é‡è¿‡å¤§
                    const step = Math.max(1, Math.floor(path.length / 10));
                    for (let i = 0; i < path.length - 1; i += step) {
                        const [r, c] = path[i];
                        const startKey = `${r},${c}`;
                        if (!this.indexToAxial.has(startKey)) continue;
                        const [q, axR] = this.indexToAxial.get(startKey);
                        
                        // å°è¯•6ä¸ªæ–¹å‘
                        for (const [dq, dr] of AXIAL_DIRS) {
                            // ä¼˜å…ˆåˆ¶é€ é•¿è·³åˆ†æ”¯ (4, 6)
                            for (const factor of [4, 6]) {
                                const targetQ = q + dq * factor;
                                const targetR = axR + dr * factor;
                                const targetKey = `${targetQ},${targetR}`;
                                
                                const midQ = q + dq * (factor/2);
                                const midR = axR + dr * (factor/2);
                                const midKey = `${midQ},${midR}`;
                                
                                if (this.axialToIndex.has(targetKey) && this.axialToIndex.has(midKey)) {
                                    const [tr, tc] = this.axialToIndex.get(targetKey);
                                    const [mr, mc] = this.axialToIndex.get(midKey);
                                    
                                    // æ¡ä»¶ï¼š
                                    // 1. ç›®æ ‡ä½ä¸ºç©º
                                    // 2. ä¸­é—´ä½ä¸ºç©º (æˆ‘ä»¬éœ€è¦æ”¾éšœç¢ç‰©)
                                    // 3. ä¸­é—´ä½ä¸æ˜¯ä¿ç•™ä½
                                    if (this.board[tr][tc] === EMPTY && 
                                        this.board[mr][mc] === EMPTY && 
                                        !reservedSet.has(`${mr},${mc}`)) {
                                            
                                        // æ£€æŸ¥è·¯å¾„æ˜¯å¦é€šç•… (é™¤äº†ä¸­é—´ç‚¹)
                                        let pathClear = true;
                                        for(let k=1; k<factor; k++) {
                                            if(k === factor/2) continue;
                                            const pq = q + dq * k;
                                            const pr = axR + dr * k;
                                            const pKey = `${pq},${pr}`;
                                            if(!this.axialToIndex.has(pKey)) { pathClear = false; break; }
                                            const [prIdx, pcIdx] = this.axialToIndex.get(pKey);
                                            if(this.board[prIdx][pcIdx] !== EMPTY) { pathClear = false; break; }
                                        }
                                        
                                        if (pathClear) {
                                            // è¿™æ˜¯ä¸€ä¸ªå€™é€‰ä½ç½®
                                            candidates.push({mr, mc, tr, tc});
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (candidates.length === 0) break;
                    
                    // éšæœºé€‰æ‹©ä¸€ä¸ªå€™é€‰ä½ç½®
                    const choice = candidates[Math.floor(Math.random() * candidates.length)];
                    
                    // æ”¾ç½®éšœç¢ç‰©
                    this.board[choice.mr][choice.mc] = OBSTACLE;
                    this.assignRandomColor(choice.mr, choice.mc);
                    this.createAxialMapping();
                    
                    // éªŒè¯
                    const newPath = this.solveGameBFS(this.board, this.playerPos);
                    
                    // å¿…é¡»æ»¡è¶³ï¼š
                    // 1. ä»æœ‰è§£
                    // 2. æ­¥æ•°æ²¡æœ‰å¤§å¹…å‡å°‘ (æ·å¾„æ£€æµ‹)
                    // 3. åˆ†æ”¯ç³»æ•°æœ‰æ‰€æé«˜ (å¯é€‰ï¼Œæˆ–è€…æ˜¯è‡³å°‘ä¸é™ä½å¤ªå¤š)
                    if (!newPath || (newPath.length - 1) < minSteps * 0.95) {
                        // å¤±è´¥å›æ»š
                        this.board[choice.mr][choice.mc] = EMPTY;
                        this.boardColors[choice.mr][choice.mc] = null;
                        this.createAxialMapping();
                    } else {
                        // æˆåŠŸä¿ç•™
                        currentBranching = this.calculateAvgBranchingFactor(newPath);
                        // å¯ä»¥é€‰æ‹©å°†æ–°ç‚¹åŠ å…¥reservedï¼Œæˆ–è€…ä¸åŠ å…è®¸è¢«åç»­ä¿®æ”¹
                    }
                }
            }
            
             // è¿™æ˜¯ä¸€ä¸ªå¤‡ç”¨çš„ã€ç®€å•çš„éšæœºæ·»åŠ å¹²æ‰°é¡¹çš„æ–¹æ³•
             addRandomDecoys(targetBranching, reservedSet, minSteps, initialPath) {
                  const noiseCandidates = this.getDecoyCandidates(initialPath, reservedSet);
                  // Shuffle
                   for (let i = noiseCandidates.length - 1; i > 0; i--) {
                      const j = Math.floor(Math.random() * (i + 1));
                      [noiseCandidates[i], noiseCandidates[j]] = [noiseCandidates[j], noiseCandidates[i]];
                  }
                  
                  let addedCount = 0;
                  const maxDecoys = 20;
                  
                  for (const [r, c] of noiseCandidates) {
                      if (addedCount >= maxDecoys) break;
                      if (this.board[r][c] !== EMPTY) continue;
                      
                      this.board[r][c] = OBSTACLE;
                      this.createAxialMapping();
                      
                      // éªŒè¯æ˜¯å¦ç ´åäº†ä¸»è·¯å¾„ (ä¸¥é˜²æ·å¾„)
                      const checkPath = this.solveGameBFS(this.board, this.playerPos);
                      // å¦‚æœæ— è§£ï¼Œæˆ–è€…æ–°è·¯å¾„æ¯”åŸå®šç›®æ ‡æ­¥æ•°è¿˜çŸ­ï¼ˆè¯´æ˜æ‰“é€šäº†æ·å¾„ï¼‰ï¼Œåˆ™å›é€€
                      if (!checkPath || (checkPath.length - 1) < minSteps * 0.9) { 
                          this.board[r][c] = EMPTY; // å›é€€
                      } else {
                          this.assignRandomColor(r, c);
                          addedCount++;
                      }
                  }
             }
             
             enhancePathBranching(path, reservedSet, baselineSteps) {
                 // å¤‡ä»½çŠ¶æ€
                 const savedBoard = this.board.map(row => [...row]);
                 const savedColors = this.boardColors.map(row => [...row]);
                 const savedPlayer = [...this.playerPos];
                 
                 try {
                     // éå†è·¯å¾„æ¯ä¸€æ­¥
                     for (let i = 0; i < path.length - 1; i++) {
                         const currentPos = path[i];
                         const nextPos = path[i+1];
                         
                         // æ¢å¤ç©å®¶ä½ç½®åˆ°è¿™ä¸€æ­¥
                         this.board[currentPos[0]][currentPos[1]] = PLAYER;
                         this.playerPos = [currentPos[0], currentPos[1]];
                         this.createAxialMapping();
                         
                         // æ£€æŸ¥å½“å‰åˆ†æ”¯æ•°
                         const jumps = this.findAllJumpsFrom(currentPos[0], currentPos[1]);
                         
                         // è¿‡æ»¤å‡ºéä¸»è·¯å¾„çš„åˆ†æ”¯
                         const altJumps = jumps.filter(j => j[0] !== nextPos[0] || j[1] !== nextPos[1]);
                         
                         if (altJumps.length > 0) {
                             // === ç­–ç•¥Aï¼šå»¶ä¼¸ç°æœ‰åˆ†æ”¯ (å¤ç”¨æ£‹å­ï¼Œå¢åŠ æ·±åº¦) ===
                             const branchStart = altJumps[Math.floor(Math.random() * altJumps.length)];
                             
                             // æ¨¡æ‹Ÿè·³åˆ° branchStart
                             const jumpInfo = this.analyzeJump(currentPos[0], currentPos[1], branchStart[0], branchStart[1]);
                             if (jumpInfo) {
                                 const [mr, mc] = jumpInfo.mid;
                                 const originalColor = this.boardColors[mr][mc];
                                 
                                 // Execute Jump temporarily
                                 this.board[currentPos[0]][currentPos[1]] = EMPTY;
                                 this.board[mr][mc] = EMPTY;
                                 this.boardColors[mr][mc] = null;
                                 this.board[branchStart[0]][branchStart[1]] = PLAYER;
                                 this.playerPos = [...branchStart];
                                 this.createAxialMapping();
                                 
                                 // Extend! (3-5 steps deep)
                                 this.generateDeadEndBranch(branchStart[0], branchStart[1], 3, reservedSet, 10);
                                 
                                 // Rollback Jump (but keep new obstacles)
                                 this.board[branchStart[0]][branchStart[1]] = EMPTY; // Player moved back
                                 this.board[currentPos[0]][currentPos[1]] = PLAYER;
                                 this.board[mr][mc] = OBSTACLE; // Restore eaten piece
                                 this.boardColors[mr][mc] = originalColor;
                                 this.playerPos = [...currentPos];
                                 this.createAxialMapping();
                             }
                         } else {
                             // === ç­–ç•¥Bï¼šåˆ¶é€ æ–°åˆ†æ”¯ (ä¼˜å…ˆå¤ç”¨) ===
                             this.createDeepBranchAt(currentPos, nextPos, reservedSet);
                         }
                         
                         // æ‰§è¡Œä¸»è·¯å¾„çš„è·³è·ƒï¼Œç»§ç»­ä¸‹ä¸€æ­¥
                         this.makeJumpInternal(currentPos, nextPos);
                     }
                 } catch (e) {
                     console.error("Enhance loop error", e);
                 } finally {
                     // æ¢å¤æœ€ç»ˆçŠ¶æ€
                     const finalBoard = this.createEmptyBoard();
                     const finalColors = this.createEmptyColorLayer();
                     
                     for(let r=0; r<BOARD_ROWS; r++) {
                         for(let c=0; c<BOARD_COLS; c++) {
                             // 1. æ¢å¤åŸå§‹éšœç¢ç‰©
                             if (savedBoard[r][c] === OBSTACLE) {
                                 finalBoard[r][c] = OBSTACLE;
                                 finalColors[r][c] = savedColors[r][c];
                             }
                             // 2. ä¿ç•™æ–°å¢éšœç¢ç‰©
                             // æ–°å¢çš„ç‰¹å¾ï¼šå½“å‰æ˜¯ OBSTACLEï¼Œä½†åŸå§‹æ˜¯ EMPTY
                             if (this.board[r][c] === OBSTACLE && savedBoard[r][c] === EMPTY) {
                                 finalBoard[r][c] = OBSTACLE;
                                 finalColors[r][c] = this.boardColors[r][c];
                             }
                             // 3. æ¢å¤ç©å®¶åˆ°åŸå§‹èµ·ç‚¹
                             if (r === savedPlayer[0] && c === savedPlayer[1]) {
                                 finalBoard[r][c] = PLAYER;
                             }
                         }
                     }
                     
                     this.board = finalBoard;
                     this.boardColors = finalColors;
                     this.playerPos = [...savedPlayer];
                     this.remainingPieces = 0;
                     for(let r=0; r<BOARD_ROWS; r++) {
                         for(let c=0; c<BOARD_COLS; c++) {
                             if(this.board[r][c] === OBSTACLE) this.remainingPieces++;
                         }
                     }
                     this.createAxialMapping();
                 }
             }
            
            makeJumpInternal(from, to) {
                 const jumpInfo = this.analyzeJump(from[0], from[1], to[0], to[1]);
                 if (jumpInfo) {
                     const [mr, mc] = jumpInfo.mid;
                     this.board[from[0]][from[1]] = EMPTY;
                     this.board[mr][mc] = EMPTY; // åƒå­
                     this.boardColors[mr][mc] = null;
                     this.board[to[0]][to[1]] = PLAYER;
                     this.playerPos = [to[0], to[1]];
                     this.createAxialMapping();
                 }
            }
            
            getDecoyCandidates(path, reservedSet) {
                const candidates = [];
                const visited = new Set();
                
                // éå†è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹
                for (const [pr, pc] of path) {
                     const pKey = `${pr},${pc}`;
                     if (!this.indexToAxial.has(pKey)) continue;
                     const [q, r_ax] = this.indexToAxial.get(pKey);
                     
                     // æ£€æŸ¥6ä¸ªæ–¹å‘
                     for (const [dq, dr] of AXIAL_DIRS) {
                         // æ£€æŸ¥è·ç¦» 1-4 (è¦†ç›–æ‰€æœ‰å¯èƒ½è·³è·ƒçš„ä¸­é—´ç‚¹ä½ç½®)
                         for (let dist = 1; dist <= 4; dist++) { 
                             const tq = q + dq * dist;
                             const tr = r_ax + dr * dist;
                             const key = `${tq},${tr}`;
                             
                             if (this.axialToIndex.has(key)) {
                                 const [cr, cc] = this.axialToIndex.get(key);
                                 const cKey = `${cr},${cc}`;
                                 
                                 // å€™é€‰ç‚¹å¿…é¡»æ˜¯ï¼šæœªè®¿é—®è¿‡ã€ä¸æ˜¯ä¿ç•™ç‚¹ã€å½“å‰æ˜¯ç©ºä½
                                 if (!visited.has(cKey) && !reservedSet.has(cKey) && this.board[cr][cc] === EMPTY) {
                                     visited.add(cKey);
                                     candidates.push([cr, cc]);
                                 }
                             }
                         }
                     }
                }
                return candidates;
            }
            
            calculateAvgBranchingFactor(path) {
                // å¦‚æœæœªæä¾› pathï¼Œåˆ™è‡ªå·±è®¡ç®—ï¼ˆå…¼å®¹æ—§è°ƒç”¨ï¼‰
                if (!path) {
                    path = this.solveGameBFS(this.board, this.playerPos);
                }
                if (!path) return 0;
                
                let totalBranches = 0;
                let steps = 0;
                
                // ä¿å­˜å½“å‰çœŸå®çŠ¶æ€
                const savedBoard = this.board.map(row => [...row]);
                const savedPlayer = this.playerPos ? [...this.playerPos] : null;
                const savedColors = this.boardColors.map(row => [...row]);
                const savedRem = this.remainingPieces;
                
                try {
                    // path: [start, p1, p2, ...]
                    // éå†è·¯å¾„ä¸Šçš„æ¯ä¸€æ­¥
                    for (let i = 0; i < path.length - 1; i++) {
                        const currentPos = path[i];
                        const nextPos = path[i+1];
                        
                        // ç¡®ä¿ç©å®¶åœ¨ currentPos (è™½ç„¶é€»è¾‘ä¸Šåº”è¯¥å·²ç»åœ¨ï¼Œä½†ä¸ºäº†ä¿é™©)
                        this.board[currentPos[0]][currentPos[1]] = PLAYER;
                        this.playerPos = currentPos;
                        this.createAxialMapping();
                        
                        // è®¡ç®—å½“å‰ä½ç½®çš„æ‰€æœ‰å¯èƒ½è·³è·ƒæ•°
                        const jumps = this.findAllJumpsFrom(currentPos[0], currentPos[1]);
                        totalBranches += jumps.length;
                        steps++;
                        
                        // æ‰‹åŠ¨æ‰§è¡Œè·³è·ƒ (ä¸è§¦å‘UIæ›´æ–°å’ŒéŸ³æ•ˆ)
                        const jumpInfo = this.analyzeJump(currentPos[0], currentPos[1], nextPos[0], nextPos[1]);
                        if (jumpInfo) {
                            // æ¸…é™¤èµ·ç‚¹
                            this.board[currentPos[0]][currentPos[1]] = EMPTY;
                            // æ¸…é™¤ä¸­é—´
                            const [mr, mc] = jumpInfo.mid;
                            this.board[mr][mc] = EMPTY;
                            this.boardColors[mr][mc] = null;
                            // è®¾ç½®ç»ˆç‚¹
                            this.board[nextPos[0]][nextPos[1]] = PLAYER;
                            this.playerPos = nextPos;
                        }
                    }
                } catch (e) {
                    console.error("Branching calculation error", e);
                } finally {
                    // æ¢å¤çŠ¶æ€
                    this.board = savedBoard;
                    this.boardColors = savedColors;
                    this.playerPos = savedPlayer;
                    this.remainingPieces = savedRem;
                    this.createAxialMapping();
                }
                
                return steps > 0 ? totalBranches / steps : 0;
            }

            // åŸºç¡€å¯»è·¯ - ç”¨äºç”Ÿæˆéª¨æ¶
            // geometricOnly: true è¡¨ç¤ºå¿½ç•¥æ£‹ç›˜ä¸Šçš„å®é™…éšœç¢ç‰©ï¼Œåªçœ‹å‡ ä½•è·ç¦»æ˜¯å¦æ»¡è¶³è·³è·ƒæ¡ä»¶
            findSkeletonPath(start, end, minFactor = 2, strictMode = false) {
                // ä½¿ç”¨å¸¦æœ‰å¯å‘å¼çš„æœç´¢ (A* style but randomized)
                const startKey = `${start[0]},${start[1]}`;
                const endKey = `${end[0]},${end[1]}`;
                
                // Queue item: { pos: [r, c], path: [...], cost: 0 }
                const queue = [{ pos: start, path: [start], cost: 0 }];
                const visited = new Map(); // key -> cost
                visited.set(startKey, 0);
                
                const bestPaths = [];
                let iterations = 0;
                const maxIterations = 5000; 
                
                while (queue.length > 0) {
                    iterations++;
                    if (iterations > maxIterations) break;
                    
                    // ç®€å•çš„å¯å‘å¼æ’åºï¼š(è·ç¦»ç›®æ ‡è¶Šè¿‘ + æ­¥æ•°è¶Šå°‘) ä¼˜å…ˆ
                    queue.sort((a, b) => {
                        const distA = Math.abs(a.pos[0] - end[0]) + Math.abs(a.pos[1] - end[1]);
                        const distB = Math.abs(b.pos[0] - end[0]) + Math.abs(b.pos[1] - end[1]);
                        return (distA + a.path.length) - (distB + b.path.length);
                    });
                    
                    const current = queue.shift();
                    const currentKey = `${current.pos[0]},${current.pos[1]}`;
                    
                    // å¦‚æœåˆ°è¾¾ç›®æ ‡é™„è¿‘ (è·ç¦»å°äºç­‰äº2ï¼Œä¸”æ–¹å‘æ­£ç¡®)
                    if (current.pos[0] === end[0] && current.pos[1] === end[1]) {
                        return current.path;
                    }
                    
                    // éšæœºæ‰“ä¹±æ–¹å‘ï¼Œå¢åŠ å¤šæ ·æ€§
                    const dirs = [...AXIAL_DIRS];
                    for (let i = dirs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirs[i], dirs[j]] = [dirs[j], dirs[i]];
                    }
                    
                    // ç¡®å®šå…è®¸çš„è·³è·ƒå› å­
                    let factors = [8, 6, 4, 2];
                    if (minFactor >= 4) {
                        if (strictMode) {
                            factors = [8, 6, 4]; // ä¸¥æ ¼æ¨¡å¼ï¼šç¦æ­¢çŸ­è·³
                        } else {
                            factors = [8, 6, 4, 2]; // éä¸¥æ ¼æ¨¡å¼ï¼šä¼˜å…ˆé•¿è·³ï¼Œä½†å…è®¸çŸ­è·³
                        }
                    }
                    
                    for (const [dq, dr] of dirs) {
                        for (const factor of factors) {
                            // å¦‚æœæ˜¯ä¸¥æ ¼æ¨¡å¼ä¸”å½“å‰å°è¯•çš„æ˜¯çŸ­è·³ï¼Œè·³è¿‡
                            if (strictMode && factor < 4) continue;
                            
                            const startK = `${current.pos[0]},${current.pos[1]}`;
                            if (!this.indexToAxial.has(startK)) continue;
                            const [q1, r1] = this.indexToAxial.get(startK);
                            
                            const nextQ = q1 + dq * factor;
                            const nextR = r1 + dr * factor;
                            const nextKey = `${nextQ},${nextR}`;
                            
                            if (this.axialToIndex.has(nextKey)) {
                                const [nr, nc] = this.axialToIndex.get(nextKey);
                                const nKey = `${nr},${nc}`;
                                
                                const newCost = current.cost + 1;
                                
                                if (!visited.has(nKey) || visited.get(nKey) > newCost) {
                                    visited.set(nKey, newCost);
                                    queue.push({
                                        pos: [nr, nc],
                                        path: [...current.path, [nr, nc]],
                                        cost: newCost
                                    });
                                }
                            }
                        }
                    }
                }
                return null;
            }

            // ç”Ÿæˆéª¨æ¶ï¼šå¯»æ‰¾ä»Start(Top)åˆ°End(Bottom)çš„æœ€çŸ­åå‘è·¯å¾„
            generateSkeleton(startPos, targetPos, difficulty) {
                // 1. ä½éš¾åº¦
                if (difficulty === 'low') {
                    return this.findSkeletonPath(startPos, targetPos, 2);
                }
                
                // 2. ä¸­ç­‰éš¾åº¦
                if (difficulty === 'medium') {
                    // ... (ä¿æŒåŸæœ‰é€»è¾‘ï¼Œç¨ä½œä¼˜åŒ–)
                     const midRows = [7, 8, 9];
                     const waypoints = [];
                     for (const r of midRows) {
                         for (let c = 0; c < BOARD_COLS; c++) {
                             if (this.board[r][c] !== INVALID) waypoints.push([r, c]);
                         }
                     }
                     
                     for (let i = 0; i < 20; i++) {
                         const wp = waypoints[Math.floor(Math.random() * waypoints.length)];
                         let path1 = this.findSkeletonPath(startPos, wp, 4, true); // å°è¯•ä¸¥æ ¼é•¿è·³
                         if (!path1) path1 = this.findSkeletonPath(startPos, wp, 4, false);
                         if (!path1) continue;
                         
                         let path2 = this.findSkeletonPath(wp, targetPos, 4, true);
                         if (!path2) path2 = this.findSkeletonPath(wp, targetPos, 4, false);
                         if (!path2) continue;
                         
                         path1.pop();
                         return path1.concat(path2);
                     }
                     return this.findSkeletonPath(startPos, targetPos, 2);
                }

                // 3. é«˜éš¾åº¦ï¼šå¼ºåˆ¶é•¿è·³è·ƒ (minFactor=4)
                if (difficulty === 'high') {
                    const leftWaypoints = [];
                    const rightWaypoints = [];
                    
                    // æ‰©å¤§è·¯ç‚¹èŒƒå›´
                    for (let r = 5; r <= 12; r++) {
                        for (let c = 0; c < BOARD_COLS; c++) {
                            if (this.board[r][c] === INVALID) continue;
                            if (c < 7) leftWaypoints.push([r, c]);
                            else if (c > 9) rightWaypoints.push([r, c]);
                        }
                    }
                    
                    // å°è¯•å¤šæ¬¡ï¼Œæå¤§å¢åŠ æˆåŠŸç‡
                    for (let i = 0; i < 50; i++) {
                        const goLeftFirst = Math.random() > 0.5;
                        const w1Set = goLeftFirst ? leftWaypoints : rightWaypoints;
                        const w2Set = goLeftFirst ? rightWaypoints : leftWaypoints;
                        
                        if (w1Set.length === 0 || w2Set.length === 0) continue;
                        
                        const w1 = w1Set[Math.floor(Math.random() * w1Set.length)];
                        const w2 = w2Set[Math.floor(Math.random() * w2Set.length)];
                        
                        // å¼ºåˆ¶ä¸¥æ ¼æ¨¡å¼ (Strict Mode)
                        // ç¬¬ä¸€æ®µï¼šèµ·ç‚¹ -> è·¯ç‚¹1
                        const p1 = this.findSkeletonPath(startPos, w1, 4, true);
                        if (!p1) continue;
                        
                        // ç¬¬äºŒæ®µï¼šè·¯ç‚¹1 -> è·¯ç‚¹2
                        const p2 = this.findSkeletonPath(w1, w2, 4, true);
                        if (!p2) continue;
                        
                        // ç¬¬ä¸‰æ®µï¼šè·¯ç‚¹2 -> ç»ˆç‚¹
                        const p3 = this.findSkeletonPath(w2, targetPos, 4, true);
                        if (!p3) continue;
                        
                        p1.pop();
                        p2.pop();
                        return p1.concat(p2).concat(p3);
                    }
                }
                
                // åªæœ‰åœ¨æå°‘æ•°æƒ…å†µä¸‹å›é€€åˆ°éä¸¥æ ¼æ¨¡å¼
                console.warn("Skeleton generation fallback to loose mode");
                return this.findSkeletonPath(startPos, targetPos, 4, false);
            }
            
            // å¤æ‚åŒ–è·¯å¾„ï¼šä¼˜å…ˆåˆ†å‰²é•¿çº¿æ®µï¼Œä¸”æ”¯æŒå¤šæ¬¡è¿­ä»£
            complexifyPath(initialPath, minSteps, startTime) {
                let path = [...initialPath];
                
                // æŒç»­å°è¯•ç›´åˆ°æ­¥æ•°è¾¾æ ‡æˆ–æ— æ³•ç»§ç»­
                while (path.length - 1 < minSteps && Date.now() - startTime < 9000) {
                    let bestSplit = null;
                    let bestSplitScore = -Infinity;
                    
                    // 1. æ‰¾å‡ºæ‰€æœ‰å¯åˆ†å‰²çš„å€™é€‰çº¿æ®µ
                    const segments = [];
                    for(let i=0; i<path.length-1; i++) {
                        const p1 = path[i];
                        const p2 = path[i+1];
                        const dist = Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
                        segments.push({idx: i, dist: dist, p1, p2});
                    }
                    
                    // ä¼˜å…ˆå¤„ç†é•¿çº¿æ®µ
                    segments.sort((a, b) => b.dist - a.dist);
                    
                    // 2. å°è¯•åˆ†å‰²
                    let improved = false;
                    
                    for (const seg of segments) {
                        const {idx, p1, p2} = seg;
                        
                        const forbidden = new Set();
                        path.forEach(p => forbidden.add(`${p[0]},${p[1]}`));
                        
                        for (let k = 0; k < path.length - 1; k++) {
                            if (k === idx) continue;
                            const jump = this.analyzeJump(path[k][0], path[k][1], path[k+1][0], path[k+1][1]);
                            if (jump) {
                                forbidden.add(`${jump.mid[0]},${jump.mid[1]}`);
                                jump.pathCells.forEach(pc => forbidden.add(`${pc[0]},${pc[1]}`));
                            }
                        }
                        
                        let candidates = [];
                        
                        for (const [dq, dr] of AXIAL_DIRS) {
                            // ä¼˜å…ˆå°è¯•é•¿è·ç¦»åˆ†å‰²ï¼šå› å­è¶Šå¤§ï¼Œè·³è·ƒè¶Šè¿œ
                            for (const factor of [6, 4, 2]) {
                                const startKey = `${p1[0]},${p1[1]}`;
                                const [q1, r1] = this.indexToAxial.get(startKey);
                                const mq = q1 + dq * factor;
                                const mr = r1 + dr * factor;
                                const mKey = `${mq},${mr}`;
                                
                                if (!this.axialToIndex.has(mKey)) continue;
                                const [mx, my] = this.axialToIndex.get(mKey);
                                const mStr = `${mx},${my}`;
                                
                                if (forbidden.has(mStr)) continue;
                                
                                const jump1 = this.analyzeJump(p1[0], p1[1], mx, my);
                                if (!jump1) continue;
                                if (forbidden.has(`${jump1.mid[0]},${jump1.mid[1]}`)) continue;
                                if (jump1.pathCells.some(pc => forbidden.has(`${pc[0]},${pc[1]}`))) continue;
                                 
                                const jump2 = this.analyzeJump(mx, my, p2[0], p2[1]);
                                if (!jump2) continue;
                                if (forbidden.has(`${jump2.mid[0]},${jump2.mid[1]}`)) continue;
                                if (jump2.pathCells.some(pc => forbidden.has(`${pc[0]},${pc[1]}`))) continue;
                                
                                // è¯„åˆ†æ ‡å‡†ï¼š
                                // 1. è·³è·ƒè·ç¦»è¶Šé•¿è¶Šå¥½ (factor)
                                // 2. å‘¨å›´è¶Šç©ºæ—·è¶Šå¥½
                                let openness = 0;
                                for(const [ddq, ddr] of AXIAL_DIRS) {
                                    const nq = mq + ddq * 2;
                                    const nr = mr + ddr * 2;
                                    const nKey = `${nq},${nr}`;
                                    if(this.axialToIndex.has(nKey)) {
                                        const [nx, ny] = this.axialToIndex.get(nKey);
                                        if(!forbidden.has(`${nx},${ny}`)) openness++;
                                    }
                                }
                                
                                // factor æƒé‡å¾ˆå¤§ï¼Œé¼“åŠ±é•¿è·³
                                candidates.push({pos: [mx, my], score: openness + factor * 2 + Math.random() * 2});
                            }
                        }
                        
                        if (candidates.length > 0) {
                            candidates.sort((a, b) => b.score - a.score);
                            const best = candidates[0].pos;
                            path.splice(idx + 1, 0, best);
                            improved = true;
                            break; 
                        }
                    }
                    
                    if (!improved) break; 
                }
                
                return path;
            }

            // é€’å½’ç”Ÿæˆè·¯å¾„ï¼ˆå›æº¯æ³•ï¼‰
            generatePathRecursively(currentSteps, minSteps, reservedCells, difficulty, targetPos, startTime) {
                // è¶…æ—¶æ£€æŸ¥
                if (Date.now() - startTime > 10000) return false;

                // 1. ç»ˆæ­¢æ¡ä»¶ï¼šåœ¨åº•éƒ¨ ä¸” æ­¥æ•°è¾¾æ ‡
                // ä¸å¼ºåˆ¶ç²¾ç¡®åˆ°è¾¾ targetPosï¼Œåªè¦åˆ°è¾¾åº•éƒ¨åŒºåŸŸå³å¯
                const inBottomTriangle = this.playerPos[0] >= 13;
                if (inBottomTriangle && currentSteps >= minSteps) {
                    return true;
                }
                
                // 2. å‰ªæï¼šå¦‚æœå·²ç»å¤ªæ·±ä½†è¿˜æ²¡åˆ°åº•ï¼Œæˆ–è€…æ­¥æ•°è¿‡å¤š
                if (currentSteps > minSteps + 15) return false;
                
                // 3. è·å–æ‰€æœ‰å¯èƒ½çš„åå‘è·³è·ƒ
                const possibleJumps = this.getAllReverseJumps(this.playerPos[0], this.playerPos[1], reservedCells);
                
                if (possibleJumps.length === 0) return false;
                
                // 4. å¯å‘å¼æ’åº
                const progress = currentSteps / minSteps;
                
                possibleJumps.sort((a, b) => {
                    const [rA, cA, mA, cmA, factorA] = a;
                    const [rB, cB, mB, cmB, factorB] = b;
                    
                    // A. å¼ºåˆ¶çº¦æŸï¼šå‰æœŸä¸¥ç¦ç›´æ¥è·³è¿›åº•éƒ¨ä¸‰è§’åŒº (ä¿æŒåŸæ ·)
                    const inBottomA = rA >= 13;
                    const inBottomB = rB >= 13;
                    if (progress < 0.8) {
                        if (inBottomA !== inBottomB) return inBottomA ? 1 : -1;
                    }

                    // B. é˜¶æ®µæ€§ç­–ç•¥
                    if (progress < 0.75) {
                        // ã€å‰æœŸç­–ç•¥ã€‘ï¼šæœ€å¤§åŒ–åˆ©ç”¨æ£‹ç›˜å®½åº¦ (æ¨ªå‘ç§»åŠ¨)
                        
                        // 1. ä¼˜å…ˆæ¨ªå‘ç§»åŠ¨ (Rowå˜åŒ–å°)
                        // è¿™æ˜¯å¢åŠ æ­¥æ•°çš„å…³é”®ï¼Œåƒè´ªåƒè›‡ä¸€æ ·æ‰«è¡
                        const diffRowA = Math.abs(rA - this.playerPos[0]);
                        const diffRowB = Math.abs(rB - this.playerPos[0]);
                        if (diffRowA !== diffRowB) {
                            // ä¼˜å…ˆé€‰æ‹©è¡Œå˜åŒ–å°çš„ (æ¨ªå‘)
                            // ç»™äºˆå·¨å¤§æƒé‡
                            return (diffRowA - diffRowB) * 5;
                        }
                        
                        // 2. ä¿æŒåœ¨ä¸­é—´åŒºåŸŸ (Rows 4-12)
                        // é¿å…è¿‡æ—©å»åº•éƒ¨ï¼Œä¹Ÿé¿å…ä¸€ç›´å¡åœ¨é¡¶éƒ¨
                        const distMidA = Math.abs(rA - 8);
                        const distMidB = Math.abs(rB - 8);
                        
                        // 3. ä¼˜å…ˆé•¿è·ç¦»
                        const scoreFactorA = factorA * 3;
                        const scoreFactorB = factorB * 3;
                        
                        // 4. éšæœºå› å­ (é«˜éš¾åº¦ä¸‹éå¸¸é‡è¦)
                        const random = Math.random() * 8;
                        
                        // ç»¼åˆæ‰“åˆ†
                        // è·ç¦»ä¸­é—´è¶Šè¿‘è¶Šå¥½ (distMidè¶Šå°è¶Šå¥½)
                        const scoreA = scoreFactorA - distMidA + random;
                        const scoreB = scoreFactorB - distMidB;
                        
                        return scoreB - scoreA;
                        
                    } else {
                        // ã€åæœŸç­–ç•¥ã€‘ï¼šå†²åˆº
                        // ç›®æ ‡å¼•å¯¼ï¼šä¼˜å…ˆé€‰æ‹©è·ç¦»ç›®æ ‡ç‚¹æ›´è¿‘çš„è·³è·ƒ
                        if (targetPos) {
                            // è®¡ç®—å½“å‰ä½ç½®åˆ°ç›®æ ‡çš„è·ç¦»ï¼ˆç®€å•è¡Œè· + åˆ—è·ï¼‰
                            // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦è®¡ç®— jumpTo ä½ç½®åˆ° targetPos çš„è·ç¦»
                            const distA = Math.abs(rA - targetPos[0]) + Math.abs(cA - targetPos[1]);
                            const distB = Math.abs(rB - targetPos[0]) + Math.abs(cB - targetPos[1]);
                            return distA - distB; // è·ç¦»è¶Šå°è¶Šå¥½
                        }
                        
                        if (inBottomA !== inBottomB) return inBottomA ? -1 : 1;
                        return rB - rA; // è¶Šé ä¸‹è¶Šå¥½
                    }
                });
                
                // 5. å°è¯•è·³è·ƒ
                const maxBranch = difficulty === 'medium' ? 5 : 5;
                const topMoves = possibleJumps.slice(0, maxBranch);
                
                if (Math.random() > 0.3 && topMoves.length > 1) {
                    const idx1 = Math.floor(Math.random() * topMoves.length);
                    const idx2 = Math.floor(Math.random() * topMoves.length);
                    [topMoves[idx1], topMoves[idx2]] = [topMoves[idx2], topMoves[idx1]];
                }
                
                for (const move of topMoves) {
                    const [jumpToR, jumpToC, midR, midC, factor] = move;
                    
                    // è®°å½•çŠ¶æ€ç”¨äºå›æº¯
                    const prevPlayerPos = [...this.playerPos];
                    const addedReserved = [];
                    
                    // æ‰§è¡Œåå‘è·³è·ƒ
                    // åŸä½ç½®(å½“å‰Player)å˜ç©º
                    this.board[prevPlayerPos[0]][prevPlayerPos[1]] = EMPTY;
                    // ä¸­é—´å˜éšœç¢
                    this.board[midR][midC] = OBSTACLE;
                    this.assignRandomColor(midR, midC);
                    // ç›®æ ‡ä½ç½®å˜Player
                    this.board[jumpToR][jumpToC] = PLAYER;
                    this.playerPos = [jumpToR, jumpToC];
                    
                    // æ›´æ–°reservedCells
                    // ä¿æŠ¤ï¼šåŸä½ç½®(æ­£å‘è·³è·ƒè½ç‚¹)
                    const originKey = `${prevPlayerPos[0]},${prevPlayerPos[1]}`;
                    if (!reservedCells.has(originKey)) {
                        reservedCells.add(originKey);
                        addedReserved.push(originKey);
                    }
                    
                    // ä¿æŠ¤ï¼šè·¯å¾„ä¸Šçš„ç©ºä½
                    const [q1, r1] = this.indexToAxial.get(`${prevPlayerPos[0]},${prevPlayerPos[1]}`);
                    const [q2, r2] = this.indexToAxial.get(`${jumpToR},${jumpToC}`);
                    const dq = (q2 - q1) / factor;
                    const dr = (r2 - r1) / factor;
                    for (let i = 1; i < factor; i++) {
                        if (i === factor/2) continue;
                        const pathQ = q1 + dq * i;
                        const pathR = r1 + dr * i;
                        const pathKey = `${pathQ},${pathR}`;
                        if (this.axialToIndex.has(pathKey)) {
                            const [pR, pC] = this.axialToIndex.get(pathKey);
                            const pKey = `${pR},${pC}`;
                            if (!reservedCells.has(pKey)) {
                                reservedCells.add(pKey);
                                addedReserved.push(pKey);
                            }
                        }
                    }
                    
                    // é€’å½’ä¸‹ä¸€å±‚
                    if (this.generatePathRecursively(currentSteps + 1, minSteps, reservedCells)) {
                        return true;
                    }
                    
                    // å›æº¯ï¼ˆæ’¤é”€æ“ä½œï¼‰
                    this.playerPos = prevPlayerPos;
                    this.board[jumpToR][jumpToC] = EMPTY;
                    this.board[midR][midC] = EMPTY;
                    this.boardColors[midR][midC] = null;
                    this.board[prevPlayerPos[0]][prevPlayerPos[1]] = PLAYER;
                    
                    // æ’¤é”€reserved
                    addedReserved.forEach(key => reservedCells.delete(key));
                }
                
                return false;
            }
            
            assignRandomColor(r, c) {
                const colorKeys = Object.keys(COLORS).filter(k => !['BG','EMPTY','PLAYER','SELECTED','HIGHLIGHT','WIN_AREA','WIN_AREA_BG','WIN_AREA_BORDER'].includes(k));
                this.boardColors[r][c] = COLORS[colorKeys[Math.floor(Math.random() * colorKeys.length)]];
            }
            
            // å¹¿åº¦ä¼˜å…ˆæœç´¢æ±‚è§£ï¼ˆå¯»æ‰¾æœ€çŸ­è·¯å¾„ï¼‰
            solveGameBFS(boardState, playerPos) {
                // åˆå§‹çŠ¶æ€
                // ä½¿ç”¨æ›´å®‰å…¨çš„Hashæ ¼å¼ï¼š|r,c|r,c|
                const startObsStr = this.getBoardObsHash(boardState);
                const startHash = `${playerPos[0]},${playerPos[1]}${startObsStr}`;
                
                const queue = [{
                    r: playerPos[0],
                    c: playerPos[1],
                    obsStr: startObsStr,
                    path: [[playerPos[0], playerPos[1]]] // åŒ…å«èµ·ç‚¹
                }];
                
                const visited = new Set();
                visited.add(startHash);
                
                let iterations = 0;
                const maxIterations = 30000; // ç¨å¾®å¢åŠ æœç´¢ä¸Šé™
                
                while (queue.length > 0) {
                    iterations++;
                    if (iterations > maxIterations) return null; 
                    
                    const current = queue.shift();
                    
                    // æ£€æŸ¥èƒœåˆ©
                    if (current.r <= 3) {
                        return current.path;
                    }
                    
                    // è¿˜åŸå½“å‰éšœç¢ç‰©é›†åˆ
                    // obsStr æ ¼å¼ "|r,c|r,c|"
                    // split('|') ä¼šå¾—åˆ° ["", "r,c", "r,c", ""]
                    const currentObstacles = new Set(current.obsStr.split('|').filter(s => s !== ''));
                    
                    const jumps = this.getDynamicJumpsFromSet(current.r, current.c, currentObstacles);
                    
                    for (const [tr, tc, mr, mc] of jumps) {
                        const midKey = `${mr},${mc}`;
                        if (!currentObstacles.has(midKey)) continue;
                        
                        // å®‰å…¨çš„ç§»é™¤éšœç¢ç‰©
                        // ç›´æ¥æ›¿æ¢ |midKey| ä¸º |
                        const newObsStr = current.obsStr.replace(`|${midKey}|`, '|');
                        
                        const nextHash = `${tr},${tc}${newObsStr}`;
                        
                        if (!visited.has(nextHash)) {
                            visited.add(nextHash);
                            queue.push({
                                r: tr,
                                c: tc,
                                obsStr: newObsStr,
                                path: [...current.path, [tr, tc]]
                            });
                        }
                    }
                }
                
                return null;
            }
            
            getBoardObsHash(board) {
                let obsStr = "|";
                for(let i=0; i<BOARD_ROWS; i++) {
                    for(let j=0; j<BOARD_COLS; j++) {
                        if (board[i][j] === OBSTACLE) {
                            obsStr += `${i},${j}|`;
                        }
                    }
                }
                return obsStr;
            }

            getDynamicJumpsFromSet(r, c, obstacleSet) {
                const jumps = []; 
                const startKey = `${r},${c}`;
                if (!this.indexToAxial.has(startKey)) return [];
                const [q1, r1] = this.indexToAxial.get(startKey);

                for (const [dirQ, dirR] of AXIAL_DIRS) {
                    for (const factor of [2, 4, 6, 8]) {
                        const targetQ = q1 + dirQ * factor;
                        const targetR = r1 + dirR * factor;
                        const targetKey = `${targetQ},${targetR}`;
                        const midQ = q1 + dirQ * (factor/2);
                        const midR = r1 + dirR * (factor/2);
                        const midKey = `${midQ},${midR}`;
                        
                        if (!this.axialToIndex.has(targetKey) || !this.axialToIndex.has(midKey)) continue;
                        
                        const [tr, tc] = this.axialToIndex.get(targetKey);
                        const [mr, mc] = this.axialToIndex.get(midKey);
                        
                        // 1. ä¸­é—´å¿…é¡»æ˜¯éšœç¢ç‰©
                        if (!obstacleSet.has(`${mr},${mc}`)) continue;
                        
                        // 2. ç›®æ ‡å¿…é¡»æ˜¯ç©ºä½ (ä¸åœ¨éšœç¢ç‰©é›†åˆé‡Œï¼Œä¸”ä¸æ˜¯ Invalid)
                        // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬åªçŸ¥é“éšœç¢ç‰©åœ¨å“ªã€‚
                        // æˆ‘ä»¬è¿˜éœ€è¦çŸ¥é“æ˜¯å¦æ˜¯ INVALIDã€‚axialToIndex.has ä¿è¯äº†æœ‰æ•ˆæ€§ã€‚
                        // è¿˜éœ€è¦çŸ¥é“æ˜¯å¦æ˜¯ PLAYERï¼Ÿ Solveré‡Œ Player å°±åœ¨ r,cã€‚ç›®æ ‡è‚¯å®šä¸æ˜¯ r,cã€‚
                        // æ‰€ä»¥åªè¦ target ä¸åœ¨ obstacleSet é‡Œï¼Œå°±æ˜¯ç©ºä½ (å› ä¸ºåªæœ‰ä¸€ä¸ª Player)
                        if (obstacleSet.has(`${tr},${tc}`)) continue;
                        
                        // 3. è·¯å¾„ä¸Šå…¶ä»–ä½ç½®å¿…é¡»ä¸ºç©º
                        let pathClear = true;
                        for (let i = 1; i < factor; i++) {
                            if (i === factor/2) continue; 
                            const pathQ = q1 + dirQ * i;
                            const pathR = r1 + dirR * i;
                            const pathKey = `${pathQ},${pathR}`;
                            
                            if (!this.axialToIndex.has(pathKey)) {
                                pathClear = false;
                                break;
                            }
                            
                            const [pR, pC] = this.axialToIndex.get(pathKey);
                            // æ£€æŸ¥æ˜¯å¦æ˜¯éšœç¢ç‰©
                            if (obstacleSet.has(`${pR},${pC}`)) {
                                pathClear = false;
                                break;
                            }
                        }
                        
                        if (pathClear) {
                            jumps.push([tr, tc, mr, mc]);
                        }
                    }
                }
                return jumps;
            }

            getAllReverseJumps(r, c, reservedCells = new Set()) {
                const jumps = [];
                const startKey = `${r},${c}`;
                if (!this.indexToAxial.has(startKey)) return [];
                const [q1, r1] = this.indexToAxial.get(startKey);
                
                for (const [dq, dr] of AXIAL_DIRS) {
                    for (const factor of [2, 4, 6, 8]) {
                        // åå‘ç›®æ ‡ä½ç½®
                        const targetQ = q1 + dq * factor;
                        const targetR = r1 + dr * factor;
                        const targetKey = `${targetQ},${targetR}`;
                        
                        // ä¸­é—´ä½ç½®
                        const midQ = q1 + dq * (factor/2);
                        const midR = r1 + dr * (factor/2);
                        const midKey = `${midQ},${midR}`;
                        
                        if (!this.axialToIndex.has(targetKey) || !this.axialToIndex.has(midKey)) continue;
                        
                        const [targetRIdx, targetCIdx] = this.axialToIndex.get(targetKey);
                        const [midRIdx, midCIdx] = this.axialToIndex.get(midKey);
                        
                        // æ£€æŸ¥Midæ˜¯å¦åœ¨reservedCellsä¸­
                        if (reservedCells.has(`${midRIdx},${midCIdx}`)) continue;

                        // In current state, Target and Mid must be EMPTY
                        if (this.board[targetRIdx][targetCIdx] !== EMPTY || 
                            this.board[midRIdx][midCIdx] !== EMPTY) continue;

                        // Check entire path for emptiness
                        let pathClear = true;
                        for (let i = 1; i < factor; i++) {
                            const pathQ = q1 + dq * i;
                            const pathR = r1 + dr * i;
                            const pathKey = `${pathQ},${pathR}`;
                             if (!this.axialToIndex.has(pathKey)) {
                                pathClear = false;
                                break;
                            }
                            const [pR, pC] = this.axialToIndex.get(pathKey);
                            if (this.board[pR][pC] !== EMPTY) {
                                pathClear = false;
                                break;
                            }
                        }
                        
                        if (pathClear) {
                            jumps.push([targetRIdx, targetCIdx, midRIdx, midCIdx, factor]);
                        }
                    }
                }
                return jumps;
            }
            
            exportLevel() {
                if (!this.currentLevel) return JSON.stringify(null);
                return btoa(JSON.stringify(this.currentLevel));
            }
            
            importLevel(code) {
                try {
                    const data = JSON.parse(atob(code));
                    if (data && data.obstacles && data.player) {
                        this.currentLevel = data;
                        this.restart();
                        return true;
                    }
                } catch (e) {
                    console.error(e);
                }
                return false;
            }
            
            createAxialMapping() {
                this.indexToAxial.clear();
                this.axialToIndex.clear();
                
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            const q = c - Math.floor(r / 2);
                            const axialR = r;
                            this.indexToAxial.set(`${r},${c}`, [q, axialR]);
                            this.axialToIndex.set(`${q},${axialR}`, [r, c]);
                        }
                    }
                }
            }
            
            isInside(r, c) {
                return r >= 0 && r < BOARD_ROWS && c >= 0 && c < BOARD_COLS && this.board[r][c] !== INVALID;
            }
            
            canJumpTo(startR, startC, targetR, targetC) {
                if (!this.isInside(startR, startC) || !this.isInside(targetR, targetC)) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (this.board[startR][startC] !== PLAYER) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (this.board[targetR][targetC] !== EMPTY) {
                    return {valid: false, obstaclePos: null};
                }
                
                const startKey = `${startR},${startC}`;
                const targetKey = `${targetR},${targetC}`;
                
                if (!this.indexToAxial.has(startKey) || !this.indexToAxial.has(targetKey)) {
                    return {valid: false, obstaclePos: null};
                }
                
                const [q1, r1] = this.indexToAxial.get(startKey);
                const [q2, r2] = this.indexToAxial.get(targetKey);
                
                const dq = q2 - q1;
                const dr = r2 - r1;
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å…­æ–¹å‘çš„æ•´æ•°å€
                let directionFound = false;
                let dirQ = 0, dirR = 0;
                let factor = 0;
                
                for (const [testDirQ, testDirR] of AXIAL_DIRS) {
                    if (dq === 0 && testDirQ === 0) {
                        if (dr !== 0 && dr % testDirR === 0) {
                            factor = dr / testDirR;
                            if (factor > 0) {
                                directionFound = true;
                                dirQ = testDirQ;
                                dirR = testDirR;
                                break;
                            }
                        }
                    } else if (dr === 0 && testDirR === 0) {
                        if (dq !== 0 && dq % testDirQ === 0) {
                            factor = dq / testDirQ;
                            if (factor > 0) {
                                directionFound = true;
                                dirQ = testDirQ;
                                dirR = testDirR;
                                break;
                            }
                        }
                    } else if (dq !== 0 && dr !== 0) {
                        if (dq * testDirR === dr * testDirQ) {
                            if (testDirQ !== 0 && dq % testDirQ === 0) {
                                const testFactor = dq / testDirQ;
                                if (testFactor > 0 && dr === testDirR * testFactor) {
                                    directionFound = true;
                                    dirQ = testDirQ;
                                    dirR = testDirR;
                                    factor = testFactor;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (!directionFound) {
                    return {valid: false, obstaclePos: null};
                }
                
                if (factor % 2 !== 0 || factor < 2) {
                    return {valid: false, obstaclePos: null};
                }
                
                // éšœç¢ç‰©åº”è¯¥åœ¨ä¸­é—´ä½ç½®
                const obstacleFactor = factor / 2;
                const obstacleQ = q1 + dirQ * obstacleFactor;
                const obstacleR = r1 + dirR * obstacleFactor;
                const obstacleKey = `${obstacleQ},${obstacleR}`;
                
                if (!this.axialToIndex.has(obstacleKey)) {
                    return {valid: false, obstaclePos: null};
                }
                
                const [obstacleRIdx, obstacleCIdx] = this.axialToIndex.get(obstacleKey);
                
                if (this.board[obstacleRIdx][obstacleCIdx] !== OBSTACLE) {
                    return {valid: false, obstaclePos: null};
                }
                
                // æ£€æŸ¥è·¯å¾„æ˜¯å¦ç•…é€š
                for (let i = 1; i < factor; i++) {
                    if (i === obstacleFactor) continue;
                    
                    const pathQ = q1 + dirQ * i;
                    const pathR = r1 + dirR * i;
                    const pathKey = `${pathQ},${pathR}`;
                    
                    if (!this.axialToIndex.has(pathKey)) {
                        return {valid: false, obstaclePos: null};
                    }
                    
                    const [pathRIdx, pathCIdx] = this.axialToIndex.get(pathKey);
                    
                    if (this.board[pathRIdx][pathCIdx] !== EMPTY) {
                        return {valid: false, obstaclePos: null};
                    }
                }
                
                return {valid: true, obstaclePos: [obstacleRIdx, obstacleCIdx]};
            }
            
            findAllJumpsFrom(startR, startC) {
                if (!this.isInside(startR, startC) || this.board[startR][startC] !== PLAYER) {
                    return [];
                }
                
                const possibleJumps = [];
                
                // æ£€æŸ¥æ‰€æœ‰æ–¹å‘å’Œè·ç¦»
                for (const [dirQ, dirR] of AXIAL_DIRS) {
                    for (const factor of [2, 4, 6, 8]) {
                        const startKey = `${startR},${startC}`;
                        const [q1, r1] = this.indexToAxial.get(startKey);
                        const targetQ = q1 + dirQ * factor;
                        const targetR = r1 + dirR * factor;
                        const targetKey = `${targetQ},${targetR}`;
                        
                        if (!this.axialToIndex.has(targetKey)) continue;
                        
                        const [targetRIdx, targetCIdx] = this.axialToIndex.get(targetKey);
                        
                        const {valid} = this.canJumpTo(startR, startC, targetRIdx, targetCIdx);
                        if (valid) {
                            possibleJumps.push([targetRIdx, targetCIdx]);
                        }
                    }
                }
                
                return possibleJumps;
            }
            
            makeJump(fr, fc, tr, tc) {
                const {valid, obstaclePos} = this.canJumpTo(fr, fc, tr, tc);
                if (!valid || !obstaclePos) {
                    return false;
                }
                
                const [or_, oc] = obstaclePos;
                
                // ä¿å­˜å½“å‰çŠ¶æ€
                this.saveState();
                
                // èµ·ç‚¹æ¸…ç©º
                this.board[fr][fc] = EMPTY;
                
                // ä¸­é—´éšœç¢ç‰©è¢«åƒæ‰
                this.board[or_][oc] = EMPTY;
                this.boardColors[or_][oc] = null;
                this.remainingPieces--;
                
                // ç»ˆç‚¹å˜æˆç©å®¶
                this.board[tr][tc] = PLAYER;
                this.playerPos = [tr, tc];
                
                // å¢åŠ æ­¥æ•°
                this.moveCount++;
                
                // é‡æ–°åˆ›å»ºåæ ‡æ˜ å°„
                this.createAxialMapping();
                
                // æ’­æ”¾åƒå­éŸ³æ•ˆ
                this.playCaptureSound();
                
                // æ£€æŸ¥èƒœåˆ©
                if (this.checkWin()) {
                    this.playVictorySound();
                    return true;
                }
                
                return true;
            }
            
            checkWin() {
                if (!this.playerPos) return false;
                
                const [r, c] = this.playerPos;
                // å‰4è¡Œï¼ˆçŸ©é˜µè¡Œ0-3ï¼‰æ˜¯èƒœåˆ©åŒºåŸŸ
                if (r <= 3 && this.board[r][c] === PLAYER) {
                    this.gameWon = true;
                    const victoryMsg = document.getElementById('victoryMessage');
                    victoryMsg.textContent = 'ğŸ‰ èƒœåˆ©ï¼æ£‹å­å·²åˆ°è¾¾é¡¶éƒ¨ï¼';
                    victoryMsg.style.display = 'block';
                    return true;
                }
                
                this.gameWon = false;
                return false;
            }
            
            saveState() {
                const state = {
                    board: this.board.map(row => [...row]),
                    boardColors: this.boardColors.map(row => [...row]),
                    playerPos: this.playerPos ? [...this.playerPos] : null,
                    moveCount: this.moveCount,
                    remainingPieces: this.remainingPieces
                };
                this.history.push(state);
                
                // é™åˆ¶å†å²è®°å½•é•¿åº¦
                if (this.history.length > 20) {
                    this.history.shift();
                }
            }
            
            undo() {
                if (this.history.length > 1) {
                    this.history.pop(); // ç§»é™¤å½“å‰çŠ¶æ€
                    
                    // æ¢å¤åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€
                    const prevState = this.history[this.history.length - 1];
                    
                    this.board = prevState.board.map(row => [...row]);
                    this.boardColors = prevState.boardColors.map(row => [...row]);
                    this.playerPos = prevState.playerPos ? [...prevState.playerPos] : null;
                    this.moveCount = prevState.moveCount;
                    this.remainingPieces = prevState.remainingPieces;
                    this.selected = null;
                    this.hintPath = null;
                    
                    // é‡æ–°åˆ›å»ºåæ ‡æ˜ å°„
                    this.createAxialMapping();
                    
                    // éšè—èƒœåˆ©æ¶ˆæ¯
                    document.getElementById('victoryMessage').style.display = 'none';
                    this.gameWon = false;
                    
                    this.updateUI();
                    return true;
                }
                return false;
            }
            
            restart() {
                // æ¸…ç©ºå†å²è®°å½•
                this.history = [];
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.board = this.createEmptyBoard();
                this.boardColors = this.createEmptyColorLayer();
                this.setupBoard();
                this.createAxialMapping();
                this.moveCount = 0;
                this.remainingPieces = 28;
                this.gameWon = false;
                this.selected = null;
                this.hintPath = null;
                
                // ä¿å­˜åˆå§‹çŠ¶æ€
                this.saveState();
                
                // éšè—èƒœåˆ©æ¶ˆæ¯
                document.getElementById('victoryMessage').style.display = 'none';
                
                // æ›´æ–°UIå’Œç»˜åˆ¶
                this.updateUI();
                this.draw();
            }
            
            getPixelPos(row, col) {
                const CELL_SIZE = 40;
                const X_OFFSET = this.canvas.width / 2;
                const Y_OFFSET = 120;
                
                const x = X_OFFSET + (col - BOARD_COLS / 2) * CELL_SIZE + (row % 2) * (CELL_SIZE / 2);
                const y = Y_OFFSET + row * (CELL_SIZE * 0.85);
                return [x, y];
            }
            
            getBoardPos(px, py) {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] === INVALID) continue;
                        
                        const [x, y] = this.getPixelPos(r, c);
                        const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                        
                        if (distance < 20) {
                            return [r, c];
                        }
                    }
                }
                return null;
            }
            
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶èƒœåˆ©åŒºåŸŸèƒŒæ™¯ï¼ˆå‰4è¡Œï¼‰
                for (let r = 0; r < Math.min(4, BOARD_ROWS); r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] !== INVALID) {
                            const [x, y] = this.getPixelPos(r, c);
                            
                            // åˆ›å»ºå¾„å‘æ¸å˜
                            const gradient = this.ctx.createRadialGradient(x, y, 5, x, y, 25);
                            gradient.addColorStop(0, 'rgba(144, 238, 144, 0.6)');
                            gradient.addColorStop(1, 'rgba(144, 238, 144, 0.1)');
                            
                            this.ctx.beginPath();
                            this.ctx.fillStyle = gradient;
                            this.ctx.arc(x, y, 23, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // ç»˜åˆ¶æ£‹ç›˜å’Œæ£‹å­
                for (let r = 0; r < BOARD_ROWS; r++) {
                    for (let c = 0; c < BOARD_COLS; c++) {
                        if (this.board[r][c] === INVALID) continue;
                        
                        const [x, y] = this.getPixelPos(r, c);
                        let color;
                        
                        if (this.board[r][c] === EMPTY) {
                            color = COLORS.EMPTY;
                        } else if (this.board[r][c] === OBSTACLE) {
                            color = this.boardColors[r][c] || '#aaaaaa';
                        } else if (this.board[r][c] === PLAYER) {
                            color = COLORS.PLAYER;
                        } else {
                            color = COLORS.EMPTY;
                        }
                        
                        // é€‰ä¸­æ£‹å­é«˜äº®è¾¹æ¡†
                        if (this.selected && this.selected[0] === r && this.selected[1] === c) {
                            this.ctx.beginPath();
                            this.ctx.fillStyle = COLORS.SELECTED;
                            this.ctx.arc(x, y, 20, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        // ç»˜åˆ¶æ£‹å­
                        this.ctx.beginPath();
                        this.ctx.fillStyle = color;
                        this.ctx.arc(x, y, 17, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // æ·»åŠ æ£‹å­è¾¹æ¡†
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        this.ctx.lineWidth = 1;
                        this.ctx.arc(x, y, 17, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // åœ¨ç©å®¶æ£‹å­ä¸Šç”»ä¸€ä¸ªç™½ç‚¹
                        if (this.board[r][c] === PLAYER) {
                            this.ctx.beginPath();
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // æ˜¾ç¤ºå¯è·³ç›®æ ‡ï¼ˆå…¨éƒ¨æ˜¾ç¤ºä¸ºç»¿è‰²ï¼‰
                // åªè¦ç©å®¶å­˜åœ¨ï¼Œå°±æ˜¾ç¤ºæ‰€æœ‰å¯èƒ½çš„è·³è·ƒç›®æ ‡
                if (this.playerPos) {
                    const [fr, fc] = this.playerPos;
                    const possibleJumps = this.findAllJumpsFrom(fr, fc);
                    for (const [tr, tc] of possibleJumps) {
                        const [hx, hy] = this.getPixelPos(tr, tc);
                        
                        // ä¿®æ”¹ï¼šä½¿ç”¨ç©ºå¿ƒåœ†ç¯ä»£æ›¿å®å¿ƒåœ†ï¼Œé¿å…åƒæ£‹å­
                        this.ctx.beginPath();
                        // å¤–åœˆ
                        this.ctx.arc(hx, hy, 8, 0, Math.PI * 2);
                        this.ctx.strokeStyle = '#00A844';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                        
                        // å»æ‰ä¸­å¿ƒå°ç‚¹ï¼Œç¡®ä¿çœ‹èµ·æ¥å®Œå…¨ä¸åƒæ£‹å­
                    }
                }
                
                // ç»˜åˆ¶é¼ æ ‡æ‚¬åœæ—¶çš„è·³è·ƒè·¯å¾„ç®­å¤´
                if (this.hoveredTarget && this.playerPos) {
                    const [sr, sc] = this.playerPos;
                    const [tr, tc] = this.hoveredTarget;
                    
                    const [sx, sy] = this.getPixelPos(sr, sc);
                    const [tx, ty] = this.getPixelPos(tr, tc);
                    
                    this.ctx.save();
                    this.ctx.strokeStyle = '#00A844';
                    this.ctx.fillStyle = '#00A844';
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';
                    
                    // ç»˜åˆ¶ç›´çº¿
                    this.ctx.beginPath();
                    this.ctx.moveTo(sx, sy);
                    this.ctx.lineTo(tx, ty);
                    this.ctx.stroke();
                    
                    // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
                    const angle = Math.atan2(ty - sy, tx - sx);
                    const headLen = 15;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(tx, ty);
                    this.ctx.lineTo(tx - headLen * Math.cos(angle - Math.PI / 6), ty - headLen * Math.sin(angle - Math.PI / 6));
                    this.ctx.lineTo(tx - headLen * Math.cos(angle + Math.PI / 6), ty - headLen * Math.sin(angle + Math.PI / 6));
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // ç»˜åˆ¶æç¤ºè·¯å¾„
                if (this.hintPath && this.hintPath.length > 1) {
                    this.ctx.save();
                    
                    // 1. ç»˜åˆ¶è¿çº¿
                    this.ctx.strokeStyle = '#FF4081'; 
                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.setLineDash([5, 5]); 

                    this.ctx.beginPath();
                    for (let i = 0; i < this.hintPath.length; i++) {
                        const [r, c] = this.hintPath[i];
                        const [x, y] = this.getPixelPos(r, c);
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    this.ctx.stroke();
                    
                    // 2. ç»˜åˆ¶èŠ‚ç‚¹å’Œæ•°å­—
                    this.ctx.setLineDash([]); // å®çº¿
                    for (let i = 0; i < this.hintPath.length; i++) {
                        const [r, c] = this.hintPath[i];
                        const [x, y] = this.getPixelPos(r, c);
                        
                        // ç»˜åˆ¶åœ†åœˆèƒŒæ™¯
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 10, 0, Math.PI * 2);
                        this.ctx.fillStyle = '#FF4081';
                        this.ctx.fill();
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // ç»˜åˆ¶æ•°å­—
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = 'bold 12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        
                        // Sæ˜¯èµ·ç‚¹ï¼Œæ•°å­—æ˜¯æ­¥æ•°
                        // hintPath[0]æ˜¯å½“å‰ä½ç½®(Start)
                        // hintPath[1]æ˜¯ç¬¬1æ­¥è·³åˆ°çš„ä½ç½®
                        this.ctx.fillText(i === 0 ? 'S' : i, x, y);
                    }
                    
                    this.ctx.restore();
                }
            }
            
            findSolutionPath() {
                if (!this.playerPos) return null;
                const startPos = this.playerPos;
                const queue = [[startPos[0], startPos[1]]];
                const visited = new Set();
                const startKey = `${startPos[0]},${startPos[1]}`;
                visited.add(startKey);
                const parent = new Map(); // key -> prevKey
                
                let foundGoalKey = null;

                while (queue.length > 0) {
                    const [r, c] = queue.shift();
                    
                    if (r <= 3) {
                        foundGoalKey = `${r},${c}`;
                        break;
                    }
                    
                    const jumps = this.getStaticJumpsFrom(r, c);
                    for (const [nr, nc] of jumps) {
                        const key = `${nr},${nc}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            parent.set(key, `${r},${c}`);
                            queue.push([nr, nc]);
                        }
                    }
                }
                
                if (foundGoalKey) {
                    // Reconstruct
                    const path = [];
                    let curr = foundGoalKey;
                    while (curr !== startKey) {
                        const [r, c] = curr.split(',').map(Number);
                        path.unshift([r, c]);
                        curr = parent.get(curr);
                    }
                    // Add start
                    path.unshift(startPos);
                    return path;
                }
                return null;
            }
            
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
            }
            
            playCaptureSound() {
                // åˆ›å»ºç®€å•çš„åƒå­éŸ³æ•ˆ
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (e) {
                    console.log("éŸ³é¢‘ä¸Šä¸‹æ–‡ä¸å¯ç”¨");
                }
            }
            
            playVictorySound() {
                // åˆ›å»ºç®€å•çš„èƒœåˆ©éŸ³æ•ˆ
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // æ’­æ”¾ä¸€ä¸ªèƒœåˆ©å’Œå¼¦
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                            oscillator.frequency.value = notes[i];
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.5);
                        }, i * 150);
                    }
                } catch (e) {
                    console.log("éŸ³é¢‘ä¸Šä¸‹æ–‡ä¸å¯ç”¨");
                }
            }
            
            updateUI() {
                document.getElementById('moveCount').textContent = this.moveCount;
                document.getElementById('remainingPieces').textContent = this.remainingPieces;
            }
            
            setupEventListeners() {
                // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameWon) return;
                    
                    // åªè¦ç‚¹å‡»ï¼Œå°±æ¸…é™¤æç¤º
                    if (this.hintPath) {
                        this.hintPath = null;
                        this.draw();
                    }
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const cell = this.getBoardPos(x, y);
                    if (!cell) return;
                    
                    const [r, c] = cell;
                    
                    // ç›´æ¥å°è¯•ç§»åŠ¨
                    // å¦‚æœç‚¹å‡»çš„æ˜¯ç©å®¶è‡ªå·±ï¼Œä»€ä¹ˆéƒ½ä¸åšï¼ˆæˆ–è€…å¯ä»¥åŠ ä¸ªè§†è§‰åé¦ˆï¼‰
                    if (this.board[r][c] === PLAYER) {
                        return;
                    }

                    // å°è¯•ä»å½“å‰ä½ç½®è·³åˆ°ç‚¹å‡»ä½ç½®
                    if (this.playerPos) {
                        const [fr, fc] = this.playerPos;
                        const success = this.makeJump(fr, fc, r, c);
                        if (success) {
                            this.updateUI();
                        }
                    }
                    
                    this.draw();
                });
                
                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ (ç”¨äºæ˜¾ç¤ºç®­å¤´å¼•å¯¼)
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.gameWon || !this.playerPos) return;

                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    const cell = this.getBoardPos(x, y);
                    let newHoveredTarget = null;

                    if (cell) {
                        const [r, c] = cell;
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„è·³è·ƒç›®æ ‡
                        const {valid} = this.canJumpTo(this.playerPos[0], this.playerPos[1], r, c);
                        if (valid) {
                            newHoveredTarget = [r, c];
                        }
                    }

                    // å¦‚æœçŠ¶æ€æ”¹å˜ï¼Œé‡ç»˜
                    if (this.hoveredTarget?.toString() !== newHoveredTarget?.toString()) {
                        this.hoveredTarget = newHoveredTarget;
                        this.draw();
                    }
                });
                
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undo();
                        this.draw();
                    } else if (e.ctrlKey && e.key === 'r') {
                        e.preventDefault();
                        this.restart();
                    } else if (e.key === 'Escape') {
                        this.selected = null;
                        this.draw();
                    }
                });
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('undoBtn').addEventListener('click', () => {
                    this.undo();
                    this.draw();
                });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                // æ–°æŒ‰é’®äº‹ä»¶
                document.getElementById('generateBtn').addEventListener('click', () => {
                    const difficulty = document.getElementById('difficultySelect').value;
                    this.generateLevel(difficulty);
                });
                
                document.getElementById('copyBtn').addEventListener('click', () => {
                    const code = this.exportLevel();
                    navigator.clipboard.writeText(code).then(() => {
                        alert('å…³å¡ä»£ç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                    }).catch(err => {
                        console.error('æ— æ³•å¤åˆ¶', err);
                        prompt('è¯·æ‰‹åŠ¨å¤åˆ¶ä»¥ä¸‹ä»£ç :', code);
                    });
                });
                
                document.getElementById('loadBtn').addEventListener('click', () => {
                    const code = prompt('è¯·è¾“å…¥å…³å¡ä»£ç :');
                    if (code) {
                        if (this.importLevel(code)) {
                             // Success
                        } else {
                            alert('æ— æ•ˆçš„å…³å¡ä»£ç ï¼');
                        }
                    }
                });
                
                document.getElementById('hintBtn').addEventListener('click', () => {
                    const path = this.solveGameBFS(this.board, this.playerPos);
                    if (path) {
                        this.hintPath = path;
                        this.draw();
                    } else {
                        alert('å½“å‰å±€é¢æ— è§£æˆ–æ— æ³•æ‰¾åˆ°è·¯å¾„ï¼');
                    }
                });
            }
        }
        
        // -----------------------------------------------------
        // åˆå§‹åŒ–æ¸¸æˆ
        // -----------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
        });
    </script>
</body>
</html>